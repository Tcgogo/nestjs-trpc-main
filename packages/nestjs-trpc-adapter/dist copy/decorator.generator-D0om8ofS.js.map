{"version":3,"file":"decorator.generator-D0om8ofS.js","names":["DecoratorGenerator","decorators: Decorator[]","sourceFile: SourceFile","project: Project","decorator: Decorator","propertyName: string","p: any","propertyInitializer: Expression","ConsoleLogger"],"sources":["../lib/generators/decorator.generator.ts"],"sourcesContent":["import {\n  Decorator,\n  Expression,\n  Project,\n  SourceFile,\n  SyntaxKind,\n} from 'ts-morph';\nimport type { DecoratorGeneratorMetadata } from '../interfaces/generator.interface';\nimport { ConsoleLogger, Inject, Injectable } from '@nestjs/common';\nimport { ProcedureGenerator } from './procedure.generator';\n\n@Injectable()\nexport class DecoratorGenerator {\n  @Inject(ConsoleLogger)\n  private readonly consoleLogger!: ConsoleLogger;\n\n  @Inject(ProcedureGenerator)\n  private readonly procedureGenerator!: ProcedureGenerator;\n\n  public serializeProcedureDecorators(\n    decorators: Decorator[],\n    sourceFile: SourceFile,\n    project: Project,\n  ): Array<DecoratorGeneratorMetadata> {\n    return decorators.reduce<DecoratorGeneratorMetadata[]>(\n      (array, decorator) => {\n        const decoratorName = decorator.getName();\n\n        if (decoratorName === 'Query' || decoratorName === 'Mutation') {\n          const input = this.getDecoratorPropertyValue(\n            decorator,\n            'input',\n            sourceFile,\n            project,\n          );\n          const output = this.getDecoratorPropertyValue(\n            decorator,\n            'output',\n            sourceFile,\n            project,\n          );\n\n          array.push({\n            name: decoratorName,\n            arguments: {\n              ...(input ? { input } : {}),\n              ...(output ? { output } : {}),\n            },\n          });\n        } else if (\n          decoratorName === 'UseMiddlewares' ||\n          decoratorName === 'Middlewares'\n        ) {\n          return array;\n        } else {\n          this.consoleLogger.warn(`Decorator ${decoratorName}, not supported.`);\n        }\n\n        return array;\n      },\n      [],\n    );\n  }\n\n  public getDecoratorPropertyValue(\n    decorator: Decorator,\n    propertyName: string,\n    sourceFile: SourceFile,\n    project: Project,\n  ): string | null {\n    const args = decorator.getArguments();\n\n    for (const arg of args) {\n      if (arg.getKind() === SyntaxKind.ObjectLiteralExpression) {\n        const properties = (arg as any).getProperties();\n        const property = properties.find(\n          (p: any) => p.getName() === propertyName,\n        );\n\n        if (!property) {\n          return null;\n        }\n\n        const propertyInitializer: Expression = property.getInitializer();\n        return this.procedureGenerator.flattenZodSchema(\n          propertyInitializer,\n          sourceFile,\n          project,\n          propertyInitializer.getText(),\n        );\n      }\n    }\n\n    return null;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;AAYO,+BAAMA,qBAAmB;;2CAEb;2CAGA;;CAEjB,AAAO,6BACLC,YACAC,YACAC,SACmC;;AACnC,SAAO,WAAW,OAChB,SAAC,OAAO,WAAc;GACpB,MAAM,gBAAgB,UAAU,SAAS;AAEzC,OAAI,kBAAkB,WAAW,kBAAkB,YAAY;IAC7D,MAAM,QAAQ,MAAK,0BACjB,WACA,SACA,YACA,QACD;IACD,MAAM,SAAS,MAAK,0BAClB,WACA,UACA,YACA,QACD;AAED,UAAM,KAAK;KACT,MAAM;KACN,mFACM,QAAQ,EAAE,MAAO,IAAG,CAAE,IACtB,SAAS,EAAE,OAAQ,IAAG,CAAE;IAE/B,EAAC;GACH,WACC,kBAAkB,oBAClB,kBAAkB,cAElB,QAAO;OAEP,OAAK,cAAc,KAAK,CAAC,UAAU,EAAE,cAAc,gBAAgB,CAAC,CAAC;AAGvE,UAAO;EACR,GACD,CAAE,EACH;CACF;CAED,AAAO,0BACLC,WACAC,cACAH,YACAC,SACe;EACf,MAAM,OAAO,UAAU,cAAc;AAErC,OAAK,MAAM,OAAO,KAChB,KAAI,IAAI,SAAS,KAAK,WAAW,yBAAyB;GACxD,MAAM,aAAa,AAAC,IAAY,eAAe;GAC/C,MAAM,WAAW,WAAW,KAC1B,SAACG,GAAW;aAAE,SAAS,KAAK;GAAY,EACzC;AAED,QAAK,SACH,QAAO;GAGT,MAAMC,sBAAkC,SAAS,gBAAgB;AACjE,UAAO,KAAK,mBAAmB,iBAC7B,qBACA,YACA,SACA,oBAAoB,SAAS,CAC9B;EACF;AAGH,SAAO;CACR;AACF;8BAlFE,0BAAOC,4BAAc;8BAGrB,0BAAO,mBAAmB;mDAL5B,+BAAY"}