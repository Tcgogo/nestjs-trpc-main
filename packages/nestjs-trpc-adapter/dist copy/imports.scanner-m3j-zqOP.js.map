{"version":3,"file":"imports.scanner-m3j-zqOP.js","names":["ImportsScanner","sourceFile: SourceFile","project: Project","barrelSourceFile: SourceFile","name: string"],"sources":["../lib/scanners/imports.scanner.ts"],"sourcesContent":["import { Injectable } from '@nestjs/common';\nimport { Project, SourceFile } from 'ts-morph';\nimport type { SourceFileImportsMap } from '../interfaces/generator.interface';\n\n@Injectable()\nexport class ImportsScanner {\n  public buildSourceFileImportsMap(\n    sourceFile: SourceFile,\n    project: Project,\n  ): Map<string, SourceFileImportsMap> {\n    const sourceFileImportsMap = new Map<string, SourceFileImportsMap>();\n    const importDeclarations = sourceFile.getImportDeclarations();\n\n    for (const importDeclaration of importDeclarations) {\n      const namedImports = importDeclaration.getNamedImports();\n      for (const namedImport of namedImports) {\n        const name = namedImport.getName();\n        const importedSourceFile =\n          importDeclaration.getModuleSpecifierSourceFile();\n\n        if (importedSourceFile == null) {\n          continue;\n        }\n\n        const resolvedSourceFile =\n          importedSourceFile.getFilePath().endsWith('index.ts') &&\n          !importedSourceFile.getVariableDeclaration(name)\n            ? this.resolveBarrelFileImport(importedSourceFile, name, project)\n            : importedSourceFile;\n\n        if (resolvedSourceFile == null) {\n          continue;\n        }\n\n        // Generalized logic to handle various kinds of declarations\n        const declaration =\n          resolvedSourceFile.getVariableDeclaration(name) ||\n          resolvedSourceFile.getClass(name) ||\n          resolvedSourceFile.getInterface(name) ||\n          resolvedSourceFile.getEnum(name) ||\n          resolvedSourceFile.getFunction(name);\n\n        if (declaration != null) {\n          const initializer =\n            'getInitializer' in declaration\n              ? declaration.getInitializer()\n              : declaration;\n          sourceFileImportsMap.set(name, {\n            initializer: initializer ?? declaration,\n            sourceFile: resolvedSourceFile,\n          });\n        }\n      }\n    }\n\n    return sourceFileImportsMap;\n  }\n\n  /**\n   * https://github.com/dsherret/ts-morph/issues/327\n   * Note that if the module resolution of the compiler is Classic then it won't resolve those implicit index.ts module specifiers.\n   * So for example, if the moduleResolution compiler option isn't explicitly set then setting the module\n   * compiler option to anything but ModuleKind.CommonJS will cause the module resolution kind to resolve to Classic.\n   * Additionally, if moduleResolution and the module compiler option isn't set,\n   * then a script target of ES2015 and above will also use Classic module resolution.\n   */\n  private resolveBarrelFileImport(\n    barrelSourceFile: SourceFile,\n    name: string,\n    project: Project,\n  ): SourceFile | undefined {\n    // Traverse through export declarations to find the actual source of the named import\n    for (const exportDeclaration of barrelSourceFile.getExportDeclarations()) {\n      const exportedSourceFile =\n        exportDeclaration.getModuleSpecifierSourceFile();\n      if (exportedSourceFile == null) continue;\n\n      // Check if the named export is explicitly re-exported\n      const namedExports = exportDeclaration.getNamedExports();\n      if (namedExports.length > 0) {\n        const matchingExport = namedExports.find((e) => e.getName() === name);\n        if (matchingExport) {\n          return exportedSourceFile;\n        }\n      } else {\n        // Handle `export * from ...` case: recursively resolve the export\n        const schemaVariable = exportedSourceFile.getVariableDeclaration(name);\n        if (schemaVariable) {\n          return exportedSourceFile;\n        } else {\n          // Continue resolving if it's another barrel file\n          const baseSourceFile = this.resolveBarrelFileImport(\n            exportedSourceFile,\n            name,\n            project,\n          );\n          if (baseSourceFile) return baseSourceFile;\n        }\n      }\n    }\n\n    return undefined;\n  }\n}\n"],"mappings":";;;;;;;;AAKO,2BAAMA,iBAAe;CAC1B,AAAO,0BACLC,YACAC,SACmC;EACnC,MAAM,uCAAuB,IAAI;EACjC,MAAM,qBAAqB,WAAW,uBAAuB;AAE7D,OAAK,MAAM,qBAAqB,oBAAoB;GAClD,MAAM,eAAe,kBAAkB,iBAAiB;AACxD,QAAK,MAAM,eAAe,cAAc;IACtC,MAAM,OAAO,YAAY,SAAS;IAClC,MAAM,qBACJ,kBAAkB,8BAA8B;AAElD,QAAI,sBAAsB,KACxB;IAGF,MAAM,qBACJ,mBAAmB,aAAa,CAAC,SAAS,WAAW,KACpD,mBAAmB,uBAAuB,KAAK,GAC5C,KAAK,wBAAwB,oBAAoB,MAAM,QAAQ,GAC/D;AAEN,QAAI,sBAAsB,KACxB;IAIF,MAAM,cACJ,mBAAmB,uBAAuB,KAAK,IAC/C,mBAAmB,SAAS,KAAK,IACjC,mBAAmB,aAAa,KAAK,IACrC,mBAAmB,QAAQ,KAAK,IAChC,mBAAmB,YAAY,KAAK;AAEtC,QAAI,eAAe,MAAM;KACvB,MAAM,cACJ,oBAAoB,cAChB,YAAY,gBAAgB,GAC5B;AACN,0BAAqB,IAAI,MAAM;MAC7B,aAAa,+DAAe;MAC5B,YAAY;KACb,EAAC;IACH;GACF;EACF;AAED,SAAO;CACR;;;;;;;;;CAUD,AAAQ,wBACNC,kBACAC,MACAF,SACwB;AAExB,OAAK,MAAM,qBAAqB,iBAAiB,uBAAuB,EAAE;GACxE,MAAM,qBACJ,kBAAkB,8BAA8B;AAClD,OAAI,sBAAsB,KAAM;GAGhC,MAAM,eAAe,kBAAkB,iBAAiB;AACxD,OAAI,aAAa,SAAS,GAAG;IAC3B,MAAM,iBAAiB,aAAa,KAAK,SAAC,GAAM;cAAE,SAAS,KAAK;IAAI,EAAC;AACrE,QAAI,eACF,QAAO;GAEV,OAAM;IAEL,MAAM,iBAAiB,mBAAmB,uBAAuB,KAAK;AACtE,QAAI,eACF,QAAO;SACF;KAEL,MAAM,iBAAiB,KAAK,wBAC1B,oBACA,MACA,QACD;AACD,SAAI,eAAgB,QAAO;IAC5B;GACF;EACF;AAED;CACD;AACF;+CAnGA,+BAAY"}