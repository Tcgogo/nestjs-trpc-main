{"version":3,"file":"static.generator-FNFHztAl.js","names":["StaticGenerator","sourceFile: SourceFile","schemaImportNames: Array<string>","importsMap: Map<string, SourceFileImportsMap>","importDeclarations: ImportDeclarationStructure[]","type: Type"],"sources":["../lib/generators/static.generator.ts"],"sourcesContent":["import {\n  type ImportDeclarationStructure,\n  SourceFile,\n  StructureKind,\n  Type,\n  VariableDeclarationKind,\n} from 'ts-morph';\nimport { Injectable } from '@nestjs/common';\nimport type { SourceFileImportsMap } from '../interfaces/generator.interface';\nimport * as path from 'node:path';\n\n@Injectable()\nexport class StaticGenerator {\n  public generateStaticDeclaration(sourceFile: SourceFile): void {\n    sourceFile.addImportDeclaration({\n      kind: StructureKind.ImportDeclaration,\n      moduleSpecifier: '@trpc/server',\n      namedImports: ['initTRPC'],\n    });\n    sourceFile.addImportDeclaration({\n      kind: StructureKind.ImportDeclaration,\n      moduleSpecifier: 'zod',\n      namedImports: ['z'],\n    });\n\n    sourceFile.addVariableStatements([\n      {\n        declarationKind: VariableDeclarationKind.Const,\n        declarations: [{ name: 't', initializer: 'initTRPC.create()' }],\n      },\n      {\n        declarationKind: VariableDeclarationKind.Const,\n        declarations: [{ name: 'publicProcedure', initializer: 't.procedure' }],\n      },\n    ]);\n  }\n\n  public addSchemaImports(\n    sourceFile: SourceFile,\n    schemaImportNames: Array<string>,\n    importsMap: Map<string, SourceFileImportsMap>,\n  ): void {\n    const importDeclarations: ImportDeclarationStructure[] = [];\n\n    for (const schemaImportName of schemaImportNames) {\n      for (const [importMapKey, importMapMetadata] of importsMap.entries()) {\n        if (schemaImportName == null || importMapKey !== schemaImportName) {\n          continue;\n        }\n\n        const relativePath = path.relative(\n          path.dirname(sourceFile.getFilePath()),\n          importMapMetadata.sourceFile.getFilePath().replace(/\\.ts$/, ''),\n        );\n\n        importDeclarations.push({\n          kind: StructureKind.ImportDeclaration,\n          moduleSpecifier: relativePath.startsWith('.')\n            ? relativePath\n            : `./${relativePath}`,\n          namedImports: [schemaImportName],\n        });\n      }\n    }\n\n    sourceFile.addImportDeclarations(importDeclarations);\n  }\n\n  public findCtxOutProperty(type: Type): string | undefined {\n    const typeText = type.getText();\n    const ctxOutMatch = typeText.match(/_ctx_out:\\s*{([^}]*)}/);\n\n    return ctxOutMatch ? ctxOutMatch[1].trim() : undefined;\n  }\n}\n"],"mappings":";;;;;;;;;AAYO,4BAAMA,kBAAgB;CAC3B,AAAO,0BAA0BC,YAA8B;AAC7D,aAAW,qBAAqB;GAC9B,MAAM,cAAc;GACpB,iBAAiB;GACjB,cAAc,CAAC,UAAW;EAC3B,EAAC;AACF,aAAW,qBAAqB;GAC9B,MAAM,cAAc;GACpB,iBAAiB;GACjB,cAAc,CAAC,GAAI;EACpB,EAAC;AAEF,aAAW,sBAAsB,CAC/B;GACE,iBAAiB,wBAAwB;GACzC,cAAc,CAAC;IAAE,MAAM;IAAK,aAAa;GAAqB,CAAC;EAChE,GACD;GACE,iBAAiB,wBAAwB;GACzC,cAAc,CAAC;IAAE,MAAM;IAAmB,aAAa;GAAe,CAAC;EACxE,CACF,EAAC;CACH;CAED,AAAO,iBACLA,YACAC,mBACAC,YACM;EACN,MAAMC,qBAAmD,CAAE;AAE3D,OAAK,MAAM,oBAAoB,kBAC7B,MAAK,MAAM,CAAC,cAAc,kBAAkB,IAAI,WAAW,SAAS,EAAE;AACpE,OAAI,oBAAoB,QAAQ,iBAAiB,iBAC/C;GAGF,MAAM,eAAe,KAAK,SACxB,KAAK,QAAQ,WAAW,aAAa,CAAC,EACtC,kBAAkB,WAAW,aAAa,CAAC,QAAQ,SAAS,GAAG,CAChE;AAED,sBAAmB,KAAK;IACtB,MAAM,cAAc;IACpB,iBAAiB,aAAa,WAAW,IAAI,GACzC,eACA,CAAC,EAAE,EAAE,cAAc;IACvB,cAAc,CAAC,gBAAiB;GACjC,EAAC;EACH;AAGH,aAAW,sBAAsB,mBAAmB;CACrD;CAED,AAAO,mBAAmBC,MAAgC;EACxD,MAAM,WAAW,KAAK,SAAS;EAC/B,MAAM,cAAc,SAAS,MAAM,yCAAwB;AAE3D,SAAO,cAAc,YAAY,GAAG,MAAM;CAC3C;AACF;gDA/DA,+BAAY"}