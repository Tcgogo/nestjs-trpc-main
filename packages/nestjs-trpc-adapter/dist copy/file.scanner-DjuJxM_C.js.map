{"version":3,"file":"file.scanner-DjuJxM_C.js","names":["fileUrl: string | null","path","FileScanner","skip: number","stack","error","p: string","sourcePath: string","content: string","sourceMapContent: string"],"sources":["../lib/scanners/file.scanner.ts"],"sourcesContent":["import { Injectable } from \"@nestjs/common\";\nimport * as fs from \"node:fs\";\nimport * as path from \"node:path\";\nimport type { SourceMapping } from \"../interfaces/scanner.interface\";\n\nfunction fileUrlToPath(fileUrl: string | null) {\n  if (!fileUrl) return \"\";\n\n  // 1. 移除 \"file:///\" 协议前缀\n  let path = fileUrl.replace(/^file:\\/\\/\\//i, \"\");\n\n  // 2. 处理 Windows 路径中的盘符重复问题（如 E:/E:/）\n  // 检测连续重复的盘符（例如 \"E:/E:/\"）\n  const driveLetterRepeat = /^([a-z]:)\\/(\\1\\/)/i;\n  if (driveLetterRepeat.test(path)) {\n    path = path.replace(driveLetterRepeat, \"$2\");\n  }\n\n  return path;\n}\n\n/**\n * For this specific file, using a static reference is desirable since `getCallerFilePath` uses a stack-trace to figure out the caller.\n * If this class is injected through dependency injection, that stack-trace will vary!\n */\n@Injectable()\nexport class FileScanner {\n  public getCallerFilePath(skip: number = 2): string {\n    const originalPrepareStackTrace = Error.prepareStackTrace;\n\n    Error.prepareStackTrace = (_, stack) => stack;\n    const error = new Error();\n    const stack = error.stack as unknown as NodeJS.CallSite[];\n\n    Error.prepareStackTrace = originalPrepareStackTrace;\n\n    const caller = stack[skip];\n\n    // const jsFilePath = caller?.getFileName();\n    const jsFilePath = fileUrlToPath(caller?.getFileName()); // ESM support\n\n    if (jsFilePath == null) {\n      throw new Error(`Could not find caller file: ${caller}`);\n    }\n\n    try {\n      // Attempt to find the source map file and extract the original TypeScript path\n      const sourceMap = this.getSourceMapFromJSPath(jsFilePath);\n      return this.normalizePath(\n        path.resolve(jsFilePath, \"..\", sourceMap.sources[0]),\n      );\n    } catch (error) {\n      // Suppress the warning if in test environment\n      if (process.env.NODE_ENV !== \"test\") {\n        console.warn(\n          `Warning: Could not resolve source map for ${jsFilePath}. Falling back to default path resolution.`,\n        );\n      }\n      return this.normalizePath(jsFilePath);\n    }\n  }\n\n  private normalizePath(p: string): string {\n    return path.resolve(p.replace(/\\\\/g, \"/\"));\n  }\n\n  private getPlatformPath(p: string): string {\n    const exec = /^\\/(\\w*):(.*)/.exec(p);\n    return /^win/.test(process.platform) && exec\n      ? `${exec[1]}:\\\\${exec[2].replace(/\\//g, \"\\\\\")}`\n      : p;\n  }\n\n  private getSourceMapFromJSPath(sourcePath: string): SourceMapping {\n    const SOURCE_MAP_REGEX = /\\/\\/# sourceMappingURL=(.*\\.map)$/m;\n    const filePath = this.getPlatformPath(sourcePath);\n\n    let content: string;\n    try {\n      content = fs.readFileSync(filePath, { encoding: \"utf8\" });\n    } catch (error) {\n      throw new Error(`Could not read source file at path: ${filePath}`);\n    }\n\n    const exec = SOURCE_MAP_REGEX.exec(content);\n    if (exec == null) {\n      throw new Error(\n        `Could not find source map comment in file at path ${sourcePath}. Make sure \"sourceMap\" is enabled in your tsconfig.`,\n      );\n    }\n\n    const sourceMapPath = path.resolve(filePath, \"..\", exec[1]);\n    let sourceMapContent: string;\n    try {\n      sourceMapContent = fs.readFileSync(sourceMapPath, { encoding: \"utf8\" });\n    } catch (error) {\n      throw new Error(\n        `Could not read source map file at path: ${sourceMapPath}`,\n      );\n    }\n\n    try {\n      return JSON.parse(sourceMapContent);\n    } catch (error) {\n      throw new Error(\n        `Failed to parse source map content from: ${sourceMapPath}`,\n      );\n    }\n  }\n}\n"],"mappings":";;;;;;;;;AAKA,SAAS,cAAcA,SAAwB;AAC7C,MAAK,QAAS,QAAO;CAGrB,IAAIC,SAAO,QAAQ,QAAQ,iBAAiB,GAAG;CAI/C,MAAM,oBAAoB;AAC1B,KAAI,kBAAkB,KAAKA,OAAK,CAC9B,UAAO,OAAK,QAAQ,mBAAmB,KAAK;AAG9C,QAAOA;AACR;AAOM,wBAAMC,cAAY;CACvB,AAAO,kBAAkBC,OAAe,GAAW;EACjD,MAAM,4BAA4B,MAAM;AAExC,QAAM,oBAAoB,SAAC,GAAGC,SAAU;;EAAK;EAC7C,MAAM,wBAAQ,IAAI;EAClB,MAAM,QAAQ,MAAM;AAEpB,QAAM,oBAAoB;EAE1B,MAAM,SAAS,MAAM;EAGrB,MAAM,aAAa,8DAAc,OAAQ,aAAa,CAAC;AAEvD,MAAI,cAAc,KAChB,OAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,QAAQ;AAGzD,MAAI;GAEF,MAAM,YAAY,KAAK,uBAAuB,WAAW;AACzD,UAAO,KAAK,cACV,KAAK,QAAQ,YAAY,MAAM,UAAU,QAAQ,GAAG,CACrD;EACF,SAAQC,SAAO;AAEd,OAAI,QAAQ,IAAI,aAAa,OAC3B,SAAQ,KACN,CAAC,0CAA0C,EAAE,WAAW,0CAA0C,CAAC,CACpG;AAEH,UAAO,KAAK,cAAc,WAAW;EACtC;CACF;CAED,AAAQ,cAAcC,GAAmB;AACvC,SAAO,KAAK,QAAQ,EAAE,QAAQ,OAAO,IAAI,CAAC;CAC3C;CAED,AAAQ,gBAAgBA,GAAmB;EACzC,MAAM,OAAO,kCAAgB,KAAK,EAAE;AACpC,SAAO,OAAO,KAAK,QAAQ,SAAS,IAAI,OACpC,GAAG,KAAK,GAAG,GAAG,EAAE,KAAK,GAAG,QAAQ,OAAO,KAAK,EAAE,GAC9C;CACL;CAED,AAAQ,uBAAuBC,YAAmC;EAChE,MAAM,mBAAmB;EACzB,MAAM,WAAW,KAAK,gBAAgB,WAAW;EAEjD,IAAIC;AACJ,MAAI;AACF,aAAU,GAAG,aAAa,UAAU,EAAE,UAAU,OAAQ,EAAC;EAC1D,SAAQ,OAAO;AACd,SAAM,IAAI,MAAM,CAAC,oCAAoC,EAAE,UAAU;EAClE;EAED,MAAM,OAAO,iBAAiB,KAAK,QAAQ;AAC3C,MAAI,QAAQ,KACV,OAAM,IAAI,MACR,CAAC,kDAAkD,EAAE,WAAW,oDAAoD,CAAC;EAIzH,MAAM,gBAAgB,KAAK,QAAQ,UAAU,MAAM,KAAK,GAAG;EAC3D,IAAIC;AACJ,MAAI;AACF,sBAAmB,GAAG,aAAa,eAAe,EAAE,UAAU,OAAQ,EAAC;EACxE,SAAQ,OAAO;AACd,SAAM,IAAI,MACR,CAAC,wCAAwC,EAAE,eAAe;EAE7D;AAED,MAAI;AACF,UAAO,KAAK,MAAM,iBAAiB;EACpC,SAAQ,OAAO;AACd,SAAM,IAAI,MACR,CAAC,yCAAyC,EAAE,eAAe;EAE9D;CACF;AACF;4CApFA,+BAAY"}