{"version":3,"file":"middleware.generator-BEnXpCqH.js","names":["MiddlewareGenerator","routerFilePath: string","middleware: Class<TRPCMiddleware>","project: Project","useMethod: MethodDeclaration","sourceFile: SourceFile","className: string","type: Type","properties: Array<OptionalKind<PropertySignatureStructure>>"],"sources":["../lib/generators/middleware.generator.ts"],"sourcesContent":["import {\n  ClassDeclaration,\n  Node,\n  Project,\n  MethodDeclaration,\n  Type,\n  SyntaxKind,\n  SourceFile,\n  type OptionalKind,\n  type PropertySignatureStructure,\n} from 'ts-morph';\nimport { Injectable } from '@nestjs/common';\nimport type { TRPCMiddleware } from '../interfaces';\nimport type { Class } from 'type-fest';\n\n@Injectable()\nexport class MiddlewareGenerator {\n  public async getMiddlewareInterface(\n    routerFilePath: string,\n    middleware: Class<TRPCMiddleware>,\n    project: Project,\n  ): Promise<{\n    name: string;\n    properties: Array<OptionalKind<PropertySignatureStructure>>;\n  } | null> {\n    const className = middleware.name;\n    if (!className) {\n      return null;\n    }\n\n    const middlewareInstance = new middleware();\n\n    if (typeof middlewareInstance.use !== 'function') {\n      return null;\n    }\n\n    const contextSourceFile = project.addSourceFileAtPath(routerFilePath);\n\n    const classDeclaration = this.getClassDeclaration(\n      contextSourceFile,\n      middleware.name,\n    );\n\n    if (!classDeclaration) {\n      return null;\n    }\n\n    const useMethod = classDeclaration.getMethod('use');\n    if (!useMethod) {\n      return null;\n    }\n\n    const ctxType = this.extractCtxTypeFromUseMethod(useMethod);\n    if (!ctxType) {\n      return null;\n    }\n\n    return {\n      name: className,\n      properties: this.typeToProperties(ctxType),\n    };\n  }\n\n  private extractCtxTypeFromUseMethod(\n    useMethod: MethodDeclaration,\n  ): Type | null {\n    const body = useMethod.getBody();\n    if (!body) return null;\n\n    // Find the call to opts.next()\n    const nextCall = body\n      .getDescendantsOfKind(SyntaxKind.CallExpression)\n      .find((call) => {\n        const expression = call.getExpression();\n        return (\n          Node.isPropertyAccessExpression(expression) &&\n          expression.getName() === 'next' &&\n          Node.isIdentifier(expression.getExpression()) &&\n          expression.getExpression().getText() === 'opts'\n        );\n      });\n\n    if (!nextCall) return null;\n\n    // Get the argument passed to opts.next()\n    const nextArg = nextCall.getArguments()[0];\n    if (!Node.isObjectLiteralExpression(nextArg)) return null;\n\n    // Find the 'ctx' property in the argument\n    const ctxProperty = nextArg\n      .getProperties()\n      .find(\n        (prop) => Node.isPropertyAssignment(prop) && prop.getName() === 'ctx',\n      );\n\n    if (!Node.isPropertyAssignment(ctxProperty)) return null;\n\n    // Get the type of the 'ctx' property value\n    return ctxProperty.getInitializer()?.getType() || null;\n  }\n\n  private getClassDeclaration(\n    sourceFile: SourceFile,\n    className: string,\n  ): ClassDeclaration | undefined {\n    const classDeclaration = sourceFile.getClass(className);\n    if (classDeclaration) {\n      return classDeclaration;\n    }\n    return undefined;\n  }\n\n  private typeToProperties(\n    type: Type,\n  ): Array<OptionalKind<PropertySignatureStructure>> {\n    const properties: Array<OptionalKind<PropertySignatureStructure>> = [];\n\n    if (type.isObject()) {\n      type.getProperties().forEach((prop) => {\n        const propValueDeclaration = prop.getValueDeclaration();\n        if (propValueDeclaration != null) {\n          properties.push({\n            name: prop.getName(),\n            type: prop.getTypeAtLocation(propValueDeclaration).getText(),\n          });\n        }\n      });\n    }\n\n    return properties;\n  }\n}\n"],"mappings":";;;;;;;;;;AAgBO,gCAAMA,sBAAoB;CAC/B,AAAa,uBACXC,gBACAC,YACAC;2DAIQ;GACR,MAAM,YAAY,WAAW;AAC7B,QAAK,UACH,QAAO;GAGT,MAAM,qBAAqB,IAAI;AAE/B,cAAW,mBAAmB,QAAQ,WACpC,QAAO;GAGT,MAAM,oBAAoB,QAAQ,oBAAoB,eAAe;GAErE,MAAM,mBAAmB,KAAK,oBAC5B,mBACA,WAAW,KACZ;AAED,QAAK,iBACH,QAAO;GAGT,MAAM,YAAY,iBAAiB,UAAU,MAAM;AACnD,QAAK,UACH,QAAO;GAGT,MAAM,UAAU,KAAK,4BAA4B,UAAU;AAC3D,QAAK,QACH,QAAO;AAGT,UAAO;IACL,MAAM;IACN,YAAY,KAAK,iBAAiB,QAAQ;GAC3C;EACF;;CAED,AAAQ,4BACNC,WACa;;EACb,MAAM,OAAO,UAAU,SAAS;AAChC,OAAK,KAAM,QAAO;EAGlB,MAAM,WAAW,KACd,qBAAqB,WAAW,eAAe,CAC/C,KAAK,SAAC,MAAS;GACd,MAAM,aAAa,KAAK,eAAe;AACvC,UACE,KAAK,2BAA2B,WAAW,IAC3C,WAAW,SAAS,KAAK,UACzB,KAAK,aAAa,WAAW,eAAe,CAAC,IAC7C,WAAW,eAAe,CAAC,SAAS,KAAK;EAE5C,EAAC;AAEJ,OAAK,SAAU,QAAO;EAGtB,MAAM,UAAU,SAAS,cAAc,CAAC;AACxC,OAAK,KAAK,0BAA0B,QAAQ,CAAE,QAAO;EAGrD,MAAM,cAAc,QACjB,eAAe,CACf,KACC,SAAC,MAAS;eAAK,qBAAqB,KAAK,IAAI,KAAK,SAAS,KAAK;EAAK,EACtE;AAEH,OAAK,KAAK,qBAAqB,YAAY,CAAE,QAAO;AAGpD,mCAAO,YAAY,gBAAgB,0DAA5B,sBAA8B,SAAS,KAAI;CACnD;CAED,AAAQ,oBACNC,YACAC,WAC8B;EAC9B,MAAM,mBAAmB,WAAW,SAAS,UAAU;AACvD,MAAI,iBACF,QAAO;AAET;CACD;CAED,AAAQ,iBACNC,MACiD;EACjD,MAAMC,aAA8D,CAAE;AAEtE,MAAI,KAAK,UAAU,CACjB,MAAK,eAAe,CAAC,QAAQ,SAAC,MAAS;GACrC,MAAM,uBAAuB,KAAK,qBAAqB;AACvD,OAAI,wBAAwB,KAC1B,YAAW,KAAK;IACd,MAAM,KAAK,SAAS;IACpB,MAAM,KAAK,kBAAkB,qBAAqB,CAAC,SAAS;GAC7D,EAAC;EAEL,EAAC;AAGJ,SAAO;CACR;AACF;oDApHA,+BAAY"}