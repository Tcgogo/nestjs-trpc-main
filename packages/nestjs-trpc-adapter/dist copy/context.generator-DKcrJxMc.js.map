{"version":3,"file":"context.generator-DKcrJxMc.js","names":["ContextGenerator","sourceFile: SourceFile","context: Class<TRPCContext>","createMethod: MethodDeclaration","type: Type","className: string"],"sources":["../lib/generators/context.generator.ts"],"sourcesContent":["import {\n  ClassDeclaration,\n  MethodDeclaration,\n  Type,\n  SyntaxKind,\n  SourceFile,\n} from 'ts-morph';\nimport { Injectable } from '@nestjs/common';\nimport type { TRPCContext } from '../interfaces';\nimport type { Class } from 'type-fest';\n\n@Injectable()\nexport class ContextGenerator {\n  public async getContextInterface(\n    sourceFile: SourceFile,\n    context: Class<TRPCContext>,\n  ): Promise<string | null> {\n    const className = context?.name;\n    if (!className) {\n      return null;\n    }\n\n    const contextInstance = new context();\n\n    if (typeof contextInstance.create !== 'function') {\n      return null;\n    }\n\n    const classDeclaration = this.getClassDeclaration(sourceFile, context.name);\n\n    if (!classDeclaration) {\n      return null;\n    }\n\n    const createMethod = classDeclaration.getMethod('create');\n    if (!createMethod) {\n      return null;\n    }\n\n    const ctxType = this.extractReturnTypeFromCreateMethod(createMethod);\n    if (!ctxType) {\n      return null;\n    }\n\n    return ctxType.getText();\n  }\n\n  private extractReturnTypeFromCreateMethod(\n    createMethod: MethodDeclaration,\n  ): Type | null {\n    const body = createMethod.getBody();\n    if (!body) return null;\n\n    // Find the return statement\n    const returnStatement = body\n      .getDescendantsOfKind(SyntaxKind.ReturnStatement)\n      .find((statement) => statement.getExpression() !== undefined);\n\n    if (!returnStatement) return null;\n\n    const returnExpression = returnStatement.getExpression();\n    if (!returnExpression) return null;\n\n    // Get the type of the returned expression\n    const returnType = returnExpression.getType();\n\n    // Check if the type is a Promise\n    if (this.isPromiseType(returnType)) {\n      // Get the type argument of the Promise\n      const typeArguments = returnType.getTypeArguments();\n      return typeArguments.length > 0 ? typeArguments[0] : null;\n    }\n\n    return returnType;\n  }\n\n  private isPromiseType(type: Type): boolean {\n    return (\n      type.getSymbol()?.getName() === 'Promise' ||\n      type.getSymbol()?.getName() === '__global.Promise' ||\n      type.getText().startsWith('Promise<')\n    );\n  }\n\n  private getClassDeclaration(\n    sourceFile: SourceFile,\n    className: string,\n  ): ClassDeclaration | undefined {\n    const classDeclaration = sourceFile.getClass(className);\n    if (classDeclaration) {\n      return classDeclaration;\n    }\n    return undefined;\n  }\n}\n"],"mappings":";;;;;;;;;;AAYO,6BAAMA,mBAAiB;CAC5B,AAAa,oBACXC,YACAC;2DACwB;GACxB,MAAM,8DAAY,QAAS;AAC3B,QAAK,UACH,QAAO;GAGT,MAAM,kBAAkB,IAAI;AAE5B,cAAW,gBAAgB,WAAW,WACpC,QAAO;GAGT,MAAM,mBAAmB,KAAK,oBAAoB,YAAY,QAAQ,KAAK;AAE3E,QAAK,iBACH,QAAO;GAGT,MAAM,eAAe,iBAAiB,UAAU,SAAS;AACzD,QAAK,aACH,QAAO;GAGT,MAAM,UAAU,KAAK,kCAAkC,aAAa;AACpE,QAAK,QACH,QAAO;AAGT,UAAO,QAAQ,SAAS;EACzB;;CAED,AAAQ,kCACNC,cACa;EACb,MAAM,OAAO,aAAa,SAAS;AACnC,OAAK,KAAM,QAAO;EAGlB,MAAM,kBAAkB,KACrB,qBAAqB,WAAW,gBAAgB,CAChD,KAAK,SAAC,WAAc;oBAAU,eAAe;EAAc,EAAC;AAE/D,OAAK,gBAAiB,QAAO;EAE7B,MAAM,mBAAmB,gBAAgB,eAAe;AACxD,OAAK,iBAAkB,QAAO;EAG9B,MAAM,aAAa,iBAAiB,SAAS;AAG7C,MAAI,KAAK,cAAc,WAAW,EAAE;GAElC,MAAM,gBAAgB,WAAW,kBAAkB;AACnD,UAAO,cAAc,SAAS,IAAI,cAAc,KAAK;EACtD;AAED,SAAO;CACR;CAED,AAAQ,cAAcC,MAAqB;;AACzC,6BACE,KAAK,WAAW,oDAAhB,gBAAkB,SAAS,MAAK,kCAChC,KAAK,WAAW,qDAAhB,iBAAkB,SAAS,MAAK,sBAChC,KAAK,SAAS,CAAC,WAAW,WAAW;CAExC;CAED,AAAQ,oBACNH,YACAI,WAC8B;EAC9B,MAAM,mBAAmB,WAAW,SAAS,UAAU;AACvD,MAAI,iBACF,QAAO;AAET;CACD;AACF;iDAnFA,+BAAY"}