{"version":3,"file":"procedure.generator-BS8c8w2r.js","names":["ProcedureGenerator","procedure: ProcedureGeneratorMetadata","decorator","node: Node","sourceFile: SourceFile","project: Project","schema: string"],"sources":["../lib/generators/procedure.generator.ts"],"sourcesContent":["import { Inject, Injectable } from '@nestjs/common';\nimport type { ProcedureGeneratorMetadata } from '../interfaces/generator.interface';\nimport { ProcedureType } from '../trpc.enum';\nimport { Project, SourceFile, Node } from 'ts-morph';\nimport { ImportsScanner } from '../scanners/imports.scanner';\nimport { StaticGenerator } from './static.generator';\nimport { TYPESCRIPT_APP_ROUTER_SOURCE_FILE } from './generator.constants';\n\n@Injectable()\nexport class ProcedureGenerator {\n  @Inject(ImportsScanner)\n  private readonly importsScanner!: ImportsScanner;\n\n  @Inject(StaticGenerator)\n  private readonly staticGenerator!: StaticGenerator;\n\n  @Inject(TYPESCRIPT_APP_ROUTER_SOURCE_FILE)\n  private readonly appRouterSourceFile!: SourceFile;\n\n  public generateProcedureString(\n    procedure: ProcedureGeneratorMetadata,\n  ): string {\n    const { name, decorators } = procedure;\n    const decorator = decorators.find(\n      (decorator) =>\n        decorator.name === ProcedureType.Mutation ||\n        decorator.name === ProcedureType.Query,\n    );\n\n    if (!decorator) {\n      return '';\n    }\n\n    const decoratorArgumentsArray = Object.entries(decorator.arguments)\n      .map(([key, value]) => `.${key}(${value})`)\n      .join('');\n\n    return `${name}: publicProcedure${decoratorArgumentsArray}.${decorator.name.toLowerCase()}(async () => \"PLACEHOLDER_DO_NOT_REMOVE\" as any )`;\n  }\n\n  public flattenZodSchema(\n    node: Node,\n    sourceFile: SourceFile,\n    project: Project,\n    schema: string,\n  ): string {\n    const importsMap = this.importsScanner.buildSourceFileImportsMap(\n      sourceFile,\n      project,\n    );\n    if (Node.isIdentifier(node)) {\n      const identifierName = node.getText();\n      const identifierDeclaration =\n        sourceFile.getVariableDeclaration(identifierName);\n\n      if (identifierDeclaration != null) {\n        const identifierInitializer = identifierDeclaration.getInitializer();\n\n        if (identifierInitializer != null) {\n          const identifierSchema = this.flattenZodSchema(\n            identifierInitializer,\n            sourceFile,\n            project,\n            identifierInitializer.getText(),\n          );\n\n          schema = schema.replace(identifierName, identifierSchema);\n        }\n      } else if (importsMap.has(identifierName)) {\n        const importedIdentifier = importsMap.get(identifierName);\n\n        if (importedIdentifier != null) {\n          const { initializer } = importedIdentifier;\n          const identifierSchema = this.flattenZodSchema(\n            initializer,\n            importedIdentifier.sourceFile,\n            project,\n            initializer.getText(),\n          );\n\n          schema = schema.replace(identifierName, identifierSchema);\n        }\n      }\n    } else if (Node.isObjectLiteralExpression(node)) {\n      for (const property of node.getProperties()) {\n        if (Node.isPropertyAssignment(property)) {\n          const propertyText = property.getText();\n          const propertyInitializer = property.getInitializer();\n\n          if (propertyInitializer != null) {\n            schema = schema.replace(\n              propertyText,\n              this.flattenZodSchema(\n                propertyInitializer,\n                sourceFile,\n                project,\n                propertyText,\n              ),\n            );\n          }\n        }\n      }\n    } else if (Node.isArrayLiteralExpression(node)) {\n      for (const element of node.getElements()) {\n        const elementText = element.getText();\n        schema = schema.replace(\n          elementText,\n          this.flattenZodSchema(element, sourceFile, project, elementText),\n        );\n      }\n    } else if (Node.isCallExpression(node)) {\n      const expression = node.getExpression();\n      if (\n        Node.isPropertyAccessExpression(expression) &&\n        !expression.getText().startsWith('z')\n      ) {\n        const baseSchema = this.flattenZodSchema(\n          expression,\n          sourceFile,\n          project,\n          expression.getText(),\n        );\n        const propertyName = expression.getName();\n        schema = schema.replace(\n          expression.getText(),\n          `${baseSchema}.${propertyName}`,\n        );\n      } else if (!expression.getText().startsWith('z')) {\n        this.staticGenerator.addSchemaImports(\n          this.appRouterSourceFile,\n          [expression.getText()],\n          importsMap,\n        );\n      }\n\n      for (const arg of node.getArguments()) {\n        const argText = arg.getText();\n        schema = schema.replace(\n          argText,\n          this.flattenZodSchema(arg, sourceFile, project, argText),\n        );\n      }\n    } else if (Node.isPropertyAccessExpression(node)) {\n      schema = this.flattenZodSchema(\n        node.getExpression(),\n        sourceFile,\n        project,\n        node.getExpression().getText(),\n      );\n    }\n\n    return schema;\n  }\n}\n"],"mappings":"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"}